<!DOCTYPE html>
<!--
****************************************************************************
  ATTENTION: DO NOT CHANGE ANYTHING IN THIS FILE UNLESS I EXPLICITLY ASK!!
  Only implement precisely what I request. Do not remove or alter other
  sections without explicit direction. Unexpected changes break my workflow.
****************************************************************************
-->
<html>
<head>
  <meta charset="UTF-8" />
  <title>BORED CHORD 4D</title>
  <link href="https://fonts.googleapis.com/css2?family=Martian+Mono:wght@100;200;300;400;500;600;700;800;900&display=swap" rel="stylesheet">

  <style>
    /*========================================================
      1) ROOT VARIABLES
    ========================================================*/
    :root {
      /* Color Palette */
      --background: #141214;      /* off-black */
      --primary: #FBF6E4;         /* off-white */
      --primary-accent: #E2DDCD;  /* darker off-white */
      --secondary: #DC143C;       /* red */
      --secondary-accent: #00FF7E;/* spring green */
      --black-accent: #393737;    /* dark grey */
      
      /* Layout Properties */
      --slider-width: 200px;
      --auto-width: 35px;
    }

    /*========================================================
      2) GLOBAL ELEMENTS & LAYOUT
    ========================================================*/
    body {
      background: var(--background);
      margin: 0;
      overflow: hidden;
      color: var(--primary-accent);
      font-family: 'Martian Mono', monospace;
      font-weight: 200;
      font-size: 1em;
    }
    h4 {
      font-family: 'Martian Mono', monospace;
      font-weight: 600;
      font-size: 3.1em;
    }
    .section h4 {
      margin-bottom: 25px; /* Adjust as needed */
    }
    .wireframe-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    /*========================================================
      3) TOOLBAR PANELS
    ========================================================*/
    #controlsLeft,
    #controlsRight {
      width: 400px;
      padding: 15px;
      background: rgba(20, 18, 20, 0.5);
    }
    #controlsLeft {
      position: fixed;
      top: 10px;
      left: 10px;
    }
    #controlsRight {
      position: fixed;
      top: 10px;
      right: 10px;
    }
    .section {
      margin: 0;
      padding: 10px 0;
      border-bottom: 10px solid var(--black-accent);
    }
    .section:last-child {
      margin-bottom: 0;
      padding-bottom: 0;
      border-bottom: none;
    }

    /*========================================================
      4) LABELS, GRIDS, & GENERAL INPUTS
    ========================================================*/
    #controlsLeft label {
      display: grid;
      grid-template-columns: 150px var(--slider-width) auto;
      align-items: center;
      column-gap: 10px;
      margin-bottom: 20px;
      min-height: 50px;
    }
    #freqSection label.preset {
      grid-template-columns: 150px auto;
    }
    #controlsRight .autoLabel {
      display: grid;
      grid-template-columns: var(--auto-width) var(--slider-width) 150px;
      align-items: center;
      column-gap: 10px;
      margin-bottom: 20px;
      min-height: 50px;
    }
    input[type=range],
    input[type=number] {
      width: 100%;
      box-sizing: border-box;
    }

    /*========================================================
      5) FREQUENCY NUMBER FIELDS
    ========================================================*/
    #controlsLeft input[type="number"] {
      width: 50%;
      height: 2em;
      border: 5px solid var(--secondary);
      background-color: var(--background);
      color: var(--primary);
      font-size: 1.75em;
      font-weight: 700;
      padding: 0.25em;
      text-align: center;
    }

    /* Add a green highlight on focus */
    #controlsLeft input[type="number"]:focus {
      outline: none;
      box-shadow: 0 0 0 3px var(--secondary-accent);
      border-color: var(--secondary-accent);
    }

    /* Remove spin buttons in some browsers */
    #controlsLeft input[type="number"]::-webkit-inner-spin-button,
    #controlsLeft input[type="number"]::-webkit-outer-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    #controlsLeft input[type="number"] {
      -moz-appearance: textfield; /* remove arrows on Firefox */
    }

    /*========================================================
      6) SELECT (CHORD PRESET) STYLING
    ========================================================*/
    #chordPreset {
      background-color: var(--primary);
      color: var(--black-accent);
      font-family: 'Martian Mono', monospace;
      font-weight: 300;
      font-size: 1em;
      height: 3em;
      padding: 0.5em 0.75em;
      border: 3px solid var(--secondary);
      border-radius: 0;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
    }
    #chordPreset:focus {
      outline: none;
      box-shadow: 0 0 0 3px var(--secondary-accent);
      border-radius: 0;
    }

    /*========================================================
      7) RANGE (SLIDER) STYLING
    ========================================================*/
    input[type=range] {
      -webkit-appearance: none;
      -moz-appearance: none;
      background: transparent;
      --range-progress: 50%;
      cursor: pointer;
    }
    input[type=range]::-webkit-slider-runnable-track {
      height: 25px;
      border-radius: 15px;
      background: linear-gradient(
        to right,
        var(--secondary) 0%,
        var(--secondary) var(--range-progress),
        var(--primary)   var(--range-progress),
        var(--primary)   100%
      );
    }
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      height: 48px;
      width: 48px;
      border-radius: 50%;
      background: var(--primary-accent);
      border: none;
      margin-top: -11.5px;
      outline: none;
    }
    input[type=range]::-moz-range-track {
      height: 25px;
      border-radius: 15px;
      background: linear-gradient(
        to right,
        var(--secondary) 0%,
        var(--secondary) var(--range-progress),
        var(--primary)   var(--range-progress),
        var(--primary)   100%
      );
    }
    input[type=range]::-moz-range-thumb {
      height: 48px;
      width: 48px;
      border-radius: 50%;
      background: var(--primary-accent);
      border: none;
      margin-top: -11.5px;
      outline: none;
    }

    /*========================================================
      8) CHECKBOX AUTO-TOGGLES
    ========================================================*/
    .autoMaster {
      -webkit-appearance: none;
      appearance: none;
      width: var(--auto-width);
      height: var(--auto-width);
      cursor: pointer;
      position: relative;
      background-color: var(--primary);
    }
    .autoMaster:checked::before {
      content: "";
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI3LjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAxMjAuOCA5OS4zIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCAxMjAuOCA5OS4zOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxwYXRoIGQ9Ik02My4xLDk5LjNWNjkuN0gwdi00MGg2My4xVjBsNTcuNyw0OS43TDYzLjEsOTkuM3oiLz4KPC9zdmc+Cg==) no-repeat center center;
      background-size: contain;
      background-color: var(--secondary-accent);
    }

    /*========================================================
      9) SAVE/LOAD/INITIALIZE BUTTONS
    ========================================================*/
    .saveLoadBtn {
      display: inline-block;
      background: var(--secondary); /* Red */
      color: var(--primary);        /* Off-white */
      font-family: 'Martian Mono', monospace;
      font-weight: 500;
      font-size: 1em;
      border: none;
      cursor: pointer;
      width: 120px;
      height: 40px;
      margin: 10px 0;
    }
    .saveLoadBtnRow {
      display: flex;
      justify-content: space-between;
    }
    .saveLoadBtn:hover {
      background: var(--secondary-accent); /* e.g. spring green highlight */
      color: var(--background);            /* black-ish text or your choice */
    }

    /*========================================================
      10) WAVE/WIREFRAME TOGGLE BUTTONS
    ========================================================*/
    .wave-type-btn {
      width: 50px;
      height: 50px;
      background: var(--secondary);
      color: var(--primary);
      font-family: 'Martian Mono', monospace;
      font-weight: 500;
      border: none;
      cursor: pointer;
      margin-left: -30px;
    }
    .wave-type-btn[data-wave="off"],
    .wave-type-btn[data-wireframe="off"] {
      background: var(--background);
      color: var(--secondary);
      border: 3px solid var(--secondary);
    }

    /*========================================================
      11) CANVAS
    ========================================================*/
    #myCanvas {
      display: block;
    }

  </style>
</head>
<body>
  <!-- TAPER CONFIGS -->
  <script>
    /********************************************************
     * TAPER_CONFIGS & CUSTOM TAPER FUNCTION
     ********************************************************/
    const TAPER_CONFIGS = {
      masterRateSlider:  { min:0.05,  max:0.5,   anchorPct:50, anchorVal:0.25 },
      masterRateSlider2: { min:0.5,   max:2,     anchorPct:50, anchorVal:1 },
      volumeSlider:      { min:1,     max:11,    anchorPct:50, anchorVal:5 },
      dtSlider:          { min:1e-5,  max:0.5e-1,anchorPct:20, anchorVal:0.5e-3 },
      numPointsSlider:   { min:100,   max:25000, anchorPct:20, anchorVal:800 },
      saturationSlider:  { min:0,     max:100,   anchorPct:0,  anchorVal:0 }
    };
    function customTaper(t, config) {
      let { min, max, anchorPct, anchorVal } = config;
      let a = anchorPct / 100;
      if (a <= 0 || a >= 1) {
        return min + (max - min) * t;
      }
      let e = Math.log((anchorVal - min) / (max - min)) / Math.log(a);
      return min + (max - min) * Math.pow(t, e);
    }
    function getTaperedValue(sliderId) {
      const el = document.getElementById(sliderId);
      if (!el) return 0;
      let cfg = TAPER_CONFIGS[sliderId];
      if (!cfg) {
        return parseFloat(el.value);
      }
      let rawVal = parseFloat(el.value);
      let t = rawVal / 100;
      return customTaper(t, cfg);
    }
  </script>
<!-- ===============================
    POLAR/CARTESIAN BUTTON
     =============================== -->
     <button id="coordSwitchBtn" data-mode="cartesian" style="
     position: fixed;
     bottom: 10px;
     left: 50%;
     transform: translateX(-50%);
     width: 180px;
     height: 40px;
     font-size: 1em;
     font-family: 'Martian Mono', monospace;
     font-weight: 500;
     cursor: pointer;
     background: var(--secondary);
     color: var(--primary);
     border: none;
   ">
     CARTESIAN
   </button>
   
   <style>
     /* OPTIONAL: when toggled to polar, invert style. */
     #coordSwitchBtn[data-mode="polar"] {
       background: var(--background) !important;
       color: var(--secondary) !important;
       border: 3px solid var(--secondary) !important;
     }
   </style>
   

  <!-- LEFT TOOLBAR -->
  <div id="controlsLeft">
    <div class="section" id="freqSection">
      <h4>CHORD RATIO</h4>
      <label>
        <span>Freq X:</span>
        <input id="freqX" type="number" value="3" step="0.1">
        <button id="waveTypeX" class="wave-type-btn" data-wave="sine">SINE</button>
      </label>
      <label>
        <span>Freq Y:</span>
        <input id="freqY" type="number" value="4" step="0.1">
        <button id="waveTypeY" class="wave-type-btn" data-wave="sine">SINE</button>
      </label>
      <label>
        <span>Freq Z:</span>
        <input id="freqZ" type="number" value="5" step="0.1">
        <button id="waveTypeZ" class="wave-type-btn" data-wave="sine">SINE</button>
      </label>
      <label>
        <span>Freq W:</span>
        <input id="freqW" type="number" value="6" step="0.1">
        <button id="waveTypeW" class="wave-type-btn" data-wave="sine">SINE</button>
      </label>
      <label class="preset">
        <span>Chord Presets:</span>
        <select id="chordPreset">
          <option value="">--Select Preset--</option>
          <option value="maj7">Major 7</option>
          <option value="min7">Minor 7</option>
          <option value="dom7">Dominant 7</option>
          <option value="dim7">Diminished 7</option>
          <option value="maj6">Major 6</option>
          <option value="min6">Minor 6</option>
          <option value="hdim7">Half Diminished 7</option>
          <option value="minmaj7">Minor Major 7</option>
          <option value="minb6">Minor Flat 6</option>
          <option value="augmaj7">Augmented Major 7</option>
        </select>
      </label>
      
      <div id="saveLoadSection" class="section">
        <div class="saveLoadBtnRow">
          <button id="saveSettings" class="saveLoadBtn">Save Settings</button>
          <button id="loadSettings" class="saveLoadBtn">Load Settings</button>
          <button id="initializeSettings" class="saveLoadBtn">Initialize</button>
        </div>
        <input type="file" id="loadSettingsFile" accept="application/json" style="display:none" />
      </div>
    </div>
    
    <div class="section" id="lfoSection">
      <h4>LFOs</h4>
      <label>
        <span>LFO #1 (Hz): <span id="masterRateVal">.5</span></span>
        <input id="masterRateSlider" type="range" min="0" max="100" step="0.5" value="1">
        <input id="masterRateToggle1" type="checkbox" class="autoMaster" checked>
      </label>
      <label>
        <span>LFO #2 (Hz): <span id="masterRateVal2">1</span></span>
        <input id="masterRateSlider2" type="range" min="0" max="100" step="0.5" value="25">
        <input id="masterRateToggle2" type="checkbox" class="autoMaster">
      </label>
    </div>

    <div class="section" id="outputSection">
      <h4>OUTPUT</h4>
      <label>
        <span>Volume: <span id="volVal">5</span></span>
        <input id="volumeSlider" type="range" min="0" max="100" step="0.5" value="75">
      </label>
      <label>
        <span>Δt per Point: <span id="dtVal"></span></span>
        <input id="dtSlider" type="range" min="0" max="100" step="0.5" value="40">
      </label>
      <label>
        <span># Points: <span id="numPointsVal"></span></span>
        <input id="numPointsSlider" type="range" min="0" max="100" step="0.5" value="65">
      </label>
      <label>
        <span>Curve Color: <span id="saturationVal"></span></span>
        <input id="saturationSlider" type="range" min="0" max="100" step="0.5" value="0">
      </label>
      <label class="wireframe-row">
        <span>4D Spacial Wireframe:</span>
        <button id="wireframeBtn" class="wave-type-btn" data-wireframe="off">OFF</button>
      </label>
    </div>
  </div>

  <!-- RIGHT TOOLBAR -->
  <div id="controlsRight">
    <div class="section" id="phaseSection">
      <h4>PHASE SHIFT</h4>
      <div class="autoLabel">
        <span class="rightAuto">
          <input id="phaseXAuto" type="checkbox" class="autoMaster" data-target="phaseXRange" checked>
        </span>
        <span class="rightSlider">
          <input id="phaseXRange" type="range" min="0" max="6.283185307179586" step="any" value="0">
        </span>
        <span class="rightLabel">X PHASE: <span id="phaseXVal">0</span>°</span>
      </div>
      <div class="autoLabel">
        <span class="rightAuto">
          <input id="phaseYAuto" type="checkbox" class="autoMaster" data-target="phaseYRange">
        </span>
        <span class="rightSlider">
          <input id="phaseYRange" type="range" min="0" max="6.283185307179586" step="any" value="0">
        </span>
        <span class="rightLabel">Y PHASE: <span id="phaseYVal">0</span>°</span>
      </div>
      <div class="autoLabel">
        <span class="rightAuto">
          <input id="phaseZAuto" type="checkbox" class="autoMaster" data-target="phaseZRange">
        </span>
        <span class="rightSlider">
          <input id="phaseZRange" type="range" min="0" max="6.283185307179586" step="any" value="0">
        </span>
        <span class="rightLabel">Z PHASE: <span id="phaseZVal">0</span>°</span>
      </div>
      <div class="autoLabel">
        <span class="rightAuto">
          <input id="phaseWAuto" type="checkbox" class="autoMaster" data-target="phaseWRange">
        </span>
        <span class="rightSlider">
          <input id="phaseWRange" type="range" min="0" max="6.283185307179586" step="any" value="0">
        </span>
        <span class="rightLabel">W PHASE: <span id="phaseWVal">0</span>°</span>
      </div>
    </div>
    
    <div class="section" id="rot3DSection">
      <h4>3D ROTATION</h4>
      <div class="autoLabel">
        <span class="rightAuto">
          <input id="rotXAuto" type="checkbox" class="autoMaster" data-target="rotXRange">
        </span>
        <span class="rightSlider">
          <input id="rotXRange" type="range" min="0" max="6.283185307179586" step="any" value="0">
        </span>
        <span class="rightLabel">X Axis: <span id="rotXVal">0</span>°</span>
      </div>
      <div class="autoLabel">
        <span class="rightAuto">
          <input id="rotYAuto" type="checkbox" class="autoMaster" data-target="rotYRange">
        </span>
        <span class="rightSlider">
          <input id="rotYRange" type="range" min="0" max="6.283185307179586" step="any" value="0">
        </span>
        <span class="rightLabel">Y Axis: <span id="rotYVal">0</span>°</span>
      </div>
      <div class="autoLabel">
        <span class="rightAuto">
          <input id="rotZAuto" type="checkbox" class="autoMaster" data-target="rotZRange">
        </span>
        <span class="rightSlider">
          <input id="rotZRange" type="range" min="0" max="6.283185307179586" step="any" value="0">
        </span>
        <span class="rightLabel">Z Axis: <span id="rotZVal">0</span>°</span>
      </div>
    </div>
    
    <div class="section" id="rot4DSection">
      <h4>4D ROTATION</h4>
      <div class="autoLabel">
        <span class="rightAuto">
          <input id="angle4DXYAuto" type="checkbox" class="autoMaster" data-target="angle4DXYRange">
        </span>
        <span class="rightSlider">
          <input id="angle4DXYRange" type="range" min="0" max="6.283185307179586" step="any" value="0">
        </span>
        <span class="rightLabel">XY Plane: <span id="angle4DXYVal">0</span>°</span>
      </div>
      <div class="autoLabel">
        <span class="rightAuto">
          <input id="angle4DXZAuto" type="checkbox" class="autoMaster" data-target="angle4DXZRange">
        </span>
        <span class="rightSlider">
          <input id="angle4DXZRange" type="range" min="0" max="6.283185307179586" step="any" value="0">
        </span>
        <span class="rightLabel">XZ Plane: <span id="angle4DXZVal">0</span>°</span>
      </div>
      <div class="autoLabel">
        <span class="rightAuto">
          <input id="angle4DXWAuto" type="checkbox" class="autoMaster" data-target="angle4DXWRange">
        </span>
        <span class="rightSlider">
          <input id="angle4DXWRange" type="range" min="0" max="6.283185307179586" step="any" value="0">
        </span>
        <span class="rightLabel">XW Plane: <span id="angle4DXWVal">0</span>°</span>
      </div>
      <div class="autoLabel">
        <span class="rightAuto">
          <input id="angle4DYZAuto" type="checkbox" class="autoMaster" data-target="angle4DYZRange">
        </span>
        <span class="rightSlider">
          <input id="angle4DYZRange" type="range" min="0" max="6.283185307179586" step="any" value="0">
        </span>
        <span class="rightLabel">YZ Plane: <span id="angle4DYZVal">0</span>°</span>
      </div>
      <div class="autoLabel">
        <span class="rightAuto">
          <input id="angle4DYWAuto" type="checkbox" class="autoMaster" data-target="angle4DYWRange">
        </span>
        <span class="rightSlider">
          <input id="angle4DYWRange" type="range" min="0" max="6.283185307179586" step="any" value="0">
        </span>
        <span class="rightLabel">YW Plane: <span id="angle4DYWVal">0</span>°</span>
      </div>
      <div class="autoLabel">
        <span class="rightAuto">
          <input id="angle4DZWAuto" type="checkbox" class="autoMaster" data-target="angle4DZWRange">
        </span>
        <span class="rightSlider">
          <input id="angle4DZWRange" type="range" min="0" max="6.283185307179586" step="any" value="0">
        </span>
        <span class="rightLabel">ZW Plane: <span id="angle4DZWVal">0</span>°</span>
      </div>
    </div>
  </div>

  <canvas id="myCanvas"></canvas>

  <script>
    /********************************************************
     * WAVE TOGGLES
     ********************************************************/
    document.querySelectorAll('.wave-type-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        let curr = btn.dataset.wave;
        if (curr === 'off') {
          // from off to sine
          btn.dataset.wave = 'sine';
          btn.textContent = 'SINE';
          btn.style.background = 'var(--secondary)';
          btn.style.color = 'var(--primary)';
          btn.style.border = 'none';
        } else if (curr === 'sine') {
          // from sine to triangle
          btn.dataset.wave = 'triangle';
          btn.textContent = 'TRI.';
          btn.style.background = 'var(--secondary)';
          btn.style.color = 'var(--primary)';
          btn.style.border = 'none';
        } else if (curr === 'triangle') {
          // from triangle to off
          btn.dataset.wave = 'off';
          btn.textContent = 'OFF';
          btn.style.background = 'var(--background)';
          btn.style.color = 'var(--secondary)';
          btn.style.border = '3px solid var(--secondary)';
        }
      });
    });

    /********************************************************
     * WIREFRAME ON/OFF BUTTON
     ********************************************************/
    const wireframeBtn = document.getElementById('wireframeBtn');
    wireframeBtn.addEventListener('click', () => {
      let curr = wireframeBtn.dataset.wireframe;
      if (curr === 'off') {
        // turn ON
        wireframeBtn.dataset.wireframe = 'on';
        wireframeBtn.textContent = 'ON';
        wireframeBtn.style.background = 'var(--secondary)';
        wireframeBtn.style.color = 'var(--primary)';
        wireframeBtn.style.border = 'none';
      } else {
        // turn OFF
        wireframeBtn.dataset.wireframe = 'off';
        wireframeBtn.textContent = 'OFF';
        wireframeBtn.style.background = 'var(--background)';
        wireframeBtn.style.color = 'var(--secondary)';
        wireframeBtn.style.border = '3px solid var(--secondary)';
      }
    });

    function radToDeg(rad) {
      return (rad * 180) / Math.PI;
    }

    /********************************************************
     * ROTATION SLIDERS => DATASET.PHASE
     ********************************************************/
    const rotationSliders = [
      { rangeId: 'phaseXRange',    valId: 'phaseXVal',    offset: 0 },
      { rangeId: 'phaseYRange',    valId: 'phaseYVal',    offset: 0 },
      { rangeId: 'phaseZRange',    valId: 'phaseZVal',    offset: 0 },
      { rangeId: 'phaseWRange',    valId: 'phaseWVal',    offset: 0 },
      { rangeId: 'rotXRange',      valId: 'rotXVal',      offset: 0 },
      { rangeId: 'rotYRange',      valId: 'rotYVal',      offset: 0 },
      { rangeId: 'rotZRange',      valId: 'rotZVal',      offset: Math.PI / 2 },
      { rangeId: 'angle4DXYRange', valId: 'angle4DXYVal', offset: 0 },
      { rangeId: 'angle4DXZRange', valId: 'angle4DXZVal', offset: 0 },
      { rangeId: 'angle4DXWRange', valId: 'angle4DXWVal', offset: 0 },
      { rangeId: 'angle4DYZRange', valId: 'angle4DYZVal', offset: 0 },
      { rangeId: 'angle4DYWRange', valId: 'angle4DYWVal', offset: 0 },
      { rangeId: 'angle4DZWRange', valId: 'angle4DZWVal', offset: 0 }
    ];
    rotationSliders.forEach(obj => {
      let slider = document.getElementById(obj.rangeId);
      let label = document.getElementById(obj.valId);
      if (!slider || !label) return;
      slider.addEventListener('input', e => {
        let val = parseFloat(e.target.value);
        slider.dataset.phase = val;
        let eff = (val + obj.offset) % (2 * Math.PI);
        label.textContent = radToDeg(eff).toFixed(0);
      });
      // Trigger an initial update
      slider.dispatchEvent(new Event('input'));
    });

    /********************************************************
     * FREQUENCIES & LFO SLIDERS
     ********************************************************/
    const freqXInput = document.getElementById("freqX");
    const freqYInput = document.getElementById("freqY");
    const freqZInput = document.getElementById("freqZ");
    const freqWInput = document.getElementById("freqW");

    const masterRateSlider = document.getElementById("masterRateSlider");
    const masterRateVal = document.getElementById("masterRateVal");
    const masterRateToggle1 = document.getElementById("masterRateToggle1");
    masterRateSlider.addEventListener("input", () => {
      let freq = getTaperedValue("masterRateSlider");
      masterRateVal.textContent = freq.toFixed(2);
    });
    masterRateSlider.dispatchEvent(new Event('input'));

    const masterRateSlider2 = document.getElementById("masterRateSlider2");
    const masterRateVal2 = document.getElementById("masterRateVal2");
    const masterRateToggle2 = document.getElementById("masterRateToggle2");
    masterRateSlider2.addEventListener("input", () => {
      let freq2 = getTaperedValue("masterRateSlider2");
      masterRateVal2.textContent = freq2.toFixed(2);
    });
    masterRateSlider2.dispatchEvent(new Event('input'));

    const volumeSlider = document.getElementById("volumeSlider");
    const volVal = document.getElementById("volVal");
    volumeSlider.addEventListener("input", () => {
      let v = getTaperedValue("volumeSlider");
      volVal.textContent = v.toFixed(2);
    });
    volumeSlider.dispatchEvent(new Event('input'));

    const dtSlider = document.getElementById("dtSlider");
    const dtVal = document.getElementById("dtVal");
    dtSlider.addEventListener("input", () => {
      let dt = getTaperedValue("dtSlider");
      dtVal.textContent = dt.toExponential(2);
      buildTimeArray();
    });
    dtSlider.dispatchEvent(new Event('input'));

    const numPointsSlider = document.getElementById("numPointsSlider");
    const numPointsVal = document.getElementById("numPointsVal");
    numPointsSlider.addEventListener("input", () => {
      let val = getTaperedValue("numPointsSlider");
      let n = Math.round(val);
      numPointsVal.textContent = n;
      buildTimeArray();
    });
    numPointsSlider.dispatchEvent(new Event('input'));

    const saturationSlider = document.getElementById("saturationSlider");
    const saturationVal = document.getElementById("saturationVal");
    saturationSlider.addEventListener("input", () => {
      let s = getTaperedValue("saturationSlider");
      saturationVal.textContent = s.toFixed(0);
    });
    saturationSlider.dispatchEvent(new Event('input'));

    let timeArray = [];
    function buildTimeArray() {
      timeArray = [];
      let nPoints = Math.round(getTaperedValue("numPointsSlider"));
      let dt = getTaperedValue("dtSlider");
      for (let i = 0; i < nPoints; i++) {
        timeArray.push(i * dt);
      }
    }
    buildTimeArray();

    function triangleWave(x) {
      return (2 / Math.PI) * Math.asin(Math.sin(x));
    }
    function getWaveValue(wave, angle) {
      if (wave === 'off')  return 0;
      if (wave === 'triangle') return triangleWave(angle);
      return Math.sin(angle);
    }

    /********************************************************
     * 3D ROTATIONS & 4D ROTATIONS
     ********************************************************/
    function rotateX(x, y, z, ax) {
      let c = Math.cos(ax), s = Math.sin(ax);
      return { x, y: y * c - z * s, z: y * s + z * c };
    }
    function rotateY(x, y, z, ay) {
      let c = Math.cos(ay), s = Math.sin(ay);
      return { x: z * s + x * c, y, z: z * c - x * s };
    }
    function rotateZ(x, y, z, az) {
      let c = Math.cos(az), s = Math.sin(az);
      return { x: x * c - y * s, y: x * s + y * c, z };
    }
    function rotateXYZ(x, y, z, ax, ay, az) {
      let r = rotateX(x, y, z, ax);
      r = rotateY(r.x, r.y, r.z, ay);
      r = rotateZ(r.x, r.y, r.z, az);
      return r;
    }

    // 4D rotation "helpers"
    function rotateXY(v, t) {
      let c = Math.cos(t), s = Math.sin(t);
      return { x: v.x * c - v.y * s, y: v.x * s + v.y * c, z: v.z, w: v.w };
    }
    function rotateXZ(v, t) {
      let c = Math.cos(t), s = Math.sin(t);
      return { x: v.x * c - v.z * s, y: v.y, z: v.x * s + v.z * c, w: v.w };
    }
    function rotateXW(v, t) {
      let c = Math.cos(t), s = Math.sin(t);
      return { x: v.x * c - v.w * s, y: v.y, z: v.z, w: v.x * s + v.w * c };
    }
    function rotateYZ(v, t) {
      let c = Math.cos(t), s = Math.sin(t);
      return { x: v.x, y: v.y * c - v.z * s, z: v.y * s + v.z * c, w: v.w };
    }
    function rotateYW(v, t) {
      let c = Math.cos(t), s = Math.sin(t);
      return { x: v.x, y: v.y * c - v.w * s, z: v.z, w: v.y * s + v.w * c };
    }
    function rotateZW(v, t) {
      let c = Math.cos(t), s = Math.sin(t);
      return { x: v.x, y: v.y, z: v.z * c - v.w * s, w: v.z * s + v.w * c };
    }

    /********************************************************
     * AUTOMATED SLIDER UPDATES
     ********************************************************/
    function updateAutomatedSliders(deltaTime, speed) {
      const twoPi = 2 * Math.PI;
      document.querySelectorAll('.autoMaster').forEach(auto => {
        if (auto.checked) {
          let targetId = auto.dataset.target;
          let slider = document.getElementById(targetId);
          if (slider) {
            let minVal = parseFloat(slider.min), maxVal = parseFloat(slider.max);
            let range = maxVal - minVal;
            if (Math.abs(range - twoPi) < 1e-5) {
              let phase = parseFloat(slider.dataset.phase || slider.value);
              phase += speed * deltaTime;
              slider.dataset.phase = phase;
              let wrapped = ((phase - minVal) % range + range) % range + minVal;
              slider.value = wrapped;
              slider.dispatchEvent(new Event('input'));
            } else {
              let curVal = parseFloat(slider.value);
              let newVal = curVal + speed * deltaTime;
              if (newVal > maxVal) newVal = maxVal;
              if (newVal < minVal) newVal = minVal;
              slider.value = newVal;
              slider.dispatchEvent(new Event('input'));
            }
          }
        }
      });
    }
    function getContinuousAngle(sliderId, offset = 0) {
      let slider = document.getElementById(sliderId);
      if (!slider) return offset;
      let phase = parseFloat(slider.dataset.phase || slider.value);
      return phase + offset;
    }

    /********************************************************
     * CANVAS & DRAWING
     ********************************************************/
    const canvas = document.getElementById("myCanvas");
    const ctx = canvas.getContext("2d");
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Build hypercube & 3D-cube data
    const hypercubeVertices = [];
    for (let i = 0; i < 16; i++) {
      hypercubeVertices.push({
        x: (i & 1) ? 1 : -1,
        y: (i & 2) ? 1 : -1,
        z: (i & 4) ? 1 : -1,
        w: (i & 8) ? 1 : -1
      });
    }
    const hypercubeEdges = [];
    for (let i = 0; i < 16; i++) {
      for (let bit = 0; bit < 4; bit++) {
        let j = i ^ (1 << bit);
        if (j > i) hypercubeEdges.push([i, j]);
      }
    }
    const cube3DVertices = [
      { x: -1, y: -1, z: -1, w: 0 },
      { x: 1,  y: -1, z: -1, w: 0 },
      { x: 1,  y: 1,  z: -1, w: 0 },
      { x: -1, y: 1,  z: -1, w: 0 },
      { x: -1, y: -1, z: 1,  w: 0 },
      { x: 1,  y: -1, z: 1,  w: 0 },
      { x: 1,  y: 1,  z: 1,  w: 0 },
      { x: -1, y: 1,  z: 1,  w: 0 }
    ];
    const cube3DEdges = [
      [0,1],[1,2],[2,3],[3,0],
      [4,5],[5,6],[6,7],[7,4],
      [0,4],[1,5],[2,6],[3,7]
    ];

    // Draw wireframe
    function drawWireframe(ax, ay, az, aXY, aXZ, aXW, aYZ, aYW, aZW, camZ) {
      ctx.save();
      ctx.lineWidth = 1;
      ctx.setLineDash([4,4]);
      ctx.strokeStyle = "rgba(251,246,228,0.5)";
      let hProj = [];
      for (let v of hypercubeVertices) {
        let r = rotateXY(v, aXY);
        r = rotateXZ(r, aXZ);
        r = rotateXW(r, aXW);
        r = rotateYZ(r, aYZ);
        r = rotateYW(r, aYW);
        r = rotateZW(r, aZW);

        let d4 = 5;
        let factor4 = d4 / (d4 - r.w);
        let x3 = r.x * factor4;
        let y3 = r.y * factor4;
        let z3 = r.z * factor4;
        let { x: xr, y: yr, z: zr } = rotateXYZ(x3, y3, z3, ay, ax, az);

        let denom = camZ - zr;
        if (Math.abs(denom) < 1e-5) denom = 1e-5;
        let scale = Math.min(canvas.width, canvas.height) * 0.45;
        let px = canvas.width * 0.5 + (xr / denom) * scale;
        let py = canvas.height * 0.5 - (yr / denom) * scale;
        hProj.push({ x: px, y: py });
      }
      for (let [start, end] of hypercubeEdges) {
        let A = hProj[start], B = hProj[end];
        ctx.beginPath();
        ctx.moveTo(A.x, A.y);
        ctx.lineTo(B.x, B.y);
        ctx.stroke();
      }
      ctx.restore();

      ctx.save();
      ctx.lineWidth = 2;
      ctx.setLineDash([]);
      ctx.strokeStyle = "rgba(251,246,228,0.5)";
      let cProj = [];
      for (let v of cube3DVertices) {
        let r = rotateXY(v, aXY);
        r = rotateXZ(r, aXZ);
        r = rotateXW(r, aXW);
        r = rotateYZ(r, aYZ);
        r = rotateYW(r, aYW);
        r = rotateZW(r, aZW);

        let d4 = 5;
        let factor4 = d4 / (d4 - r.w);
        let x3 = r.x * factor4;
        let y3 = r.y * factor4;
        let z3 = r.z * factor4;
        let { x: xr, y: yr, z: zr } = rotateXYZ(x3, y3, z3, ay, ax, az);

        let denom = camZ - zr;
        if (Math.abs(denom) < 1e-5) denom = 1e-5;
        let scale = Math.min(canvas.width, canvas.height) * 0.45;
        let px = canvas.width * 0.5 + (xr / denom) * scale;
        let py = canvas.height * 0.5 - (yr / denom) * scale;
        cProj.push({ x: px, y: py });
      }
      for (let [start, end] of cube3DEdges) {
        let A = cProj[start], B = cProj[end];
        ctx.beginPath();
        ctx.moveTo(A.x, A.y);
        ctx.lineTo(B.x, B.y);
        ctx.stroke();
      }
      ctx.restore();
    }
</script>
<script>
  /********************************************************
   * MAIN ANIMATION LOOP (UPDATED)
   ********************************************************/
  
  // 1) A global for coordinate mode:
  let coordMode = 'cartesian'; // default
  
  // 2) Hook up the toggle button
  const coordSwitchBtn = document.getElementById('coordSwitchBtn');
  coordSwitchBtn.addEventListener('click', () => {
    if (coordMode === 'cartesian') {
      coordMode = 'polar';
      coordSwitchBtn.dataset.mode = 'polar';
      coordSwitchBtn.textContent = 'POLAR';
    } else {
      coordMode = 'cartesian';
      coordSwitchBtn.dataset.mode = 'cartesian';
      coordSwitchBtn.textContent = 'CARTESIAN';
    }
  });
  
  // 3) A helper for wave values in [-1,1]
  function waveVal(waveType, angle) {
    if (waveType === 'off') return 0;
    if (waveType === 'triangle') {
      return (2/Math.PI)*Math.asin(Math.sin(angle));
    }
    // default => sine
    return Math.sin(angle);
  }
  
  // 4) Our animation timing
  let lastFrameTime = performance.now();
  function drawFrame(now) {
    let deltaTime = (now - lastFrameTime)*0.001;
    lastFrameTime = now;
  
    // Clear canvas each frame
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  
    // (A) EXAMPLE LFO FREQUENCY => speed (YOU can customize this logic)
    // For instance, read the two LFO sliders:
    let f1 = getTaperedValue("masterRateSlider");
    let f2 = getTaperedValue("masterRateSlider2");
    // Suppose we pick speed = 2π * f1. Or combine them if you like:
    let speed = 2 * Math.PI * f1;
    // Then update the "auto" phase sliders:
    updateAutomatedSliders(deltaTime, speed);
  
    // (B) Gather freqX,Y,Z,W + wave toggles
    let fx = parseFloat(freqXInput.value) || 3;
    let fy = parseFloat(freqYInput.value) || 4;
    let fz = parseFloat(freqZInput.value) || 5;
    let fw = parseFloat(freqWInput.value) || 6;
  
    let waveXType = waveTypeX.dataset.wave;
    let waveYType = waveTypeY.dataset.wave;
    let waveZType = waveTypeZ.dataset.wave;
    let waveWType = waveTypeW.dataset.wave;
  
    // (C) Gather phase sliders
    let phx = getContinuousAngle("phaseXRange");
    let phy = getContinuousAngle("phaseYRange");
    let phz = getContinuousAngle("phaseZRange");
    let phw = getContinuousAngle("phaseWRange");
  
    // (D) 3D + 4D rotation angles
    let ax = getContinuousAngle("rotXRange");
    let ay = getContinuousAngle("rotYRange");
    let rawAz = getContinuousAngle("rotZRange");
    let az = rawAz + Math.PI/2;  // your existing offset
  
    let aXY = getContinuousAngle("angle4DXYRange");
    let aXZ = getContinuousAngle("angle4DXZRange");
    let aXW = getContinuousAngle("angle4DXWRange");
    let aYZ = getContinuousAngle("angle4DYZRange");
    let aYW = getContinuousAngle("angle4DYWRange");
    let aZW = getContinuousAngle("angle4DZWRange");
  
    // (E) Volume => camera Z position, etc.
    let vol = getTaperedValue("volumeSlider") || 5;
    let camZ = 5 - 0.4*(vol - 1);
  
    // (F) Color saturation
    let alphaFrac = getTaperedValue("saturationSlider")/100;
  
/********************************************************
 * (G) Iterate over all timeArray points (Option B: 2D polar)
 ********************************************************/
 let n = timeArray.length;
for (let i = 0; i < n; i++) {
  let t = timeArray[i];

  // 1) Compute angles for each wave
  let angleX = 2 * Math.PI * fx * t + phx;
  let angleY = 2 * Math.PI * fy * t + phy;
  let angleZ = 2 * Math.PI * fz * t + phz;
  let angleW = 2 * Math.PI * fw * t + phw;

  // 2) Get wave values in [-1..1]
  let valX = waveVal(waveXType, angleX);
  let valY = waveVal(waveYType, angleY);
  let valZ = waveVal(waveZType, angleZ);
  let valW = waveVal(waveWType, angleW);

  // 3) Choose wave coords in either Cartesian or 2D polar (XY + ZW)
  let x4, y4, z4, w4;
  if (coordMode === 'cartesian') {
    // Same as your existing Cartesian logic:
    x4 = valX;
    y4 = valY;
    z4 = valZ;
    w4 = valW;
  } else {
    // Option B: 2D polar in (x,y) + 2D polar in (z,w)
    // Each radius is [0..2], each angle is [0..2π].
    let r1 = 1 + valX;                 // radius for XY plane
    let t1 = Math.PI * (valY + 1);     // angle for XY plane
    x4 = r1 * Math.cos(t1);
    y4 = r1 * Math.sin(t1);

    let r2 = 1 + valZ;                 // radius for ZW plane
    let t2 = Math.PI * (valW + 1);     // angle for ZW plane
    z4 = r2 * Math.cos(t2);
    w4 = r2 * Math.sin(t2);
  }

  // (H) Apply 4D rotations
  let v4 = { x: x4, y: y4, z: z4, w: w4 };
  v4 = rotateXY(v4, aXY);
  v4 = rotateXZ(v4, aXZ);
  v4 = rotateXW(v4, aXW);
  v4 = rotateYZ(v4, aYZ);
  v4 = rotateYW(v4, aYW);
  v4 = rotateZW(v4, aZW);

  // (I) 4D -> 3D perspective
  let d4 = 5;
  let factor4 = d4 / (d4 - v4.w);
  let x3 = v4.x * factor4;
  let y3 = v4.y * factor4;
  let z3 = v4.z * factor4;

  // 3D rotation
  let r3 = rotateXYZ(x3, y3, z3, ay, ax, az);
  let xr = r3.x, yr = r3.y, zr = r3.z;

  // (J) Camera 3D -> 2D
  let denom = camZ - zr;
  if (Math.abs(denom) < 1e-5) continue;
  let scale = Math.min(canvas.width, canvas.height) * 0.45;
  let px = canvas.width * 0.5 + (xr / denom) * scale;
  let py = canvas.height * 0.5 - (yr / denom) * scale;

  // (K) Draw wave point (same color logic as before)
  let radius = 2;
  let whiteAlpha = 1 - alphaFrac;
  let hue = (zr + 1) * 180;

  if (whiteAlpha > 0) {
    ctx.fillStyle = `rgba(251,246,228,${whiteAlpha})`;
    ctx.beginPath();
    ctx.arc(px, py, radius, 0, 2 * Math.PI);
    ctx.fill();
  }
  ctx.fillStyle = `hsla(${hue}, 100%, 50%, ${alphaFrac})`;
  ctx.beginPath();
  ctx.arc(px, py, radius, 0, 2 * Math.PI);
  ctx.fill();
}

  
    // (L) If wireframe is ON, draw either hypercube or 4D-sphere
    if (wireframeBtn.dataset.wireframe === 'on') {
      if (coordMode === 'cartesian') {
        drawWireframe(ax, ay, az, aXY, aXZ, aXW, aYZ, aYW, aZW, camZ);
      } else {
        drawWireframePolar(ax, ay, az, aXY, aXZ, aXW, aYZ, aYW, aZW, camZ);
      }
    }
  
    // Repeat animation
    requestAnimationFrame(drawFrame);
  }
  // Kickstart the loop
  requestAnimationFrame(drawFrame);
  </script>


  <!-- Slider gradient fill -->
  <script>
    /********************************************************
     * DYNAMIC SLIDER TRACK GRADIENT
     ********************************************************/
    document.querySelectorAll('input[type=range]').forEach(slider => {
      slider.addEventListener('input', () => {
        let min = parseFloat(slider.min) || 0,
            max = parseFloat(slider.max) || 100,
            val = parseFloat(slider.value);
        let pct = ((val - min) * 100 / (max - min)) + '%';
        slider.style.setProperty('--range-progress', pct);
      });
      slider.dispatchEvent(new Event('input'));
    });
  </script>

  <!-- Chord Preset Dropdown Handling -->
  <script>
    /********************************************************
     * CHORD PRESET DROPDOWN
     ********************************************************/
    document.getElementById('chordPreset').addEventListener('change', function() {
      const presets = {
        maj7:     [8, 10, 12, 15],
        min7:     [10, 12, 15, 18],
        dom7:     [20, 25, 30, 36],
        dim7:     [125, 150, 180, 216],
        maj6:     [16, 20, 24, 27],
        min6:     [80, 96, 120, 135],
        hdim7:    [25, 30, 36, 45],
        minmaj7:  [40, 48, 60, 75],
        minb6:    [10, 12, 15, 16],
        augmaj7:  [16, 20, 25, 30]
      };
      const freqIDs = ['freqX','freqY','freqZ','freqW'];
      const values = presets[this.value];
      if (values) {
        freqIDs.forEach((id, i) => {
          document.getElementById(id).value = values[i];
        });
      }
      freqIDs.forEach(id => {
        document.getElementById(id).dispatchEvent(new Event('input'));
      });
    });
  </script>

  <script>
    /********************************************************
     * RESPONSIVE SCALING OF TOOLBARS
     ********************************************************/
    function scaleToolbar(toolbar) {
      const viewportHeight = window.innerHeight;
      const toolbarHeight = toolbar.scrollHeight;
      const scale = Math.min(1, viewportHeight / toolbarHeight);
      toolbar.style.transform = `scale(${scale})`;
      if (toolbar.id === "controlsRight") {
        toolbar.style.transformOrigin = "top right";
      } else {
        toolbar.style.transformOrigin = "top left";
      }
    }
    const controlsLeft = document.getElementById("controlsLeft");
    const controlsRight = document.getElementById("controlsRight");
    scaleToolbar(controlsLeft);
    scaleToolbar(controlsRight);
    window.addEventListener("resize", () => {
      scaleToolbar(controlsLeft);
      scaleToolbar(controlsRight);
    });
  </script>

  <script>
    /********************************************************
     * (A) BUILD FILENAME FROM FREQUENCIES
     ********************************************************/
    function getFrequencyFileName() {
      const fx = document.getElementById("freqX").value;
      const fy = document.getElementById("freqY").value;
      const fz = document.getElementById("freqZ").value;
      const fw = document.getElementById("freqW").value;
      return `${fx}_${fy}_${fz}_${fw}_BC4D.json`;
    }

    /********************************************************
     * (B) WAVE/WIREFRAME BUTTON UI HELPERS
     ********************************************************/
    function updateWaveButtonUI(btn, waveState) {
      btn.dataset.wave = waveState;
      switch (waveState) {
        case 'off':
          btn.textContent = 'OFF';
          btn.style.background = 'var(--background)';
          btn.style.color = 'var(--secondary)';
          btn.style.border = '3px solid var(--secondary)';
          break;
        case 'sine':
          btn.textContent = 'SINE';
          btn.style.background = 'var(--secondary)';
          btn.style.color = 'var(--primary)';
          btn.style.border = 'none';
          break;
        case 'triangle':
          btn.textContent = 'TRI.';
          btn.style.background = 'var(--secondary)';
          btn.style.color = 'var(--primary)';
          btn.style.border = 'none';
          break;
      }
    }

    function updateWireframeButtonUI(btn, wireframeState) {
      btn.dataset.wireframe = wireframeState;
      if (wireframeState === 'on') {
        btn.textContent = 'ON';
        btn.style.background = 'var(--secondary)';
        btn.style.color = 'var(--primary)';
        btn.style.border = 'none';
      } else {
        btn.textContent = 'OFF';
        btn.style.background = 'var(--background)';
        btn.style.color = 'var(--secondary)';
        btn.style.border = '3px solid var(--secondary)';
      }
    }

    /********************************************************
     * (C) GET ALL CURRENT SETTINGS => JSON
     ********************************************************/
    function getSettings() {
      const settings = {};
      const allInputs = document.querySelectorAll(
        "#controlsLeft input, #controlsLeft select, #controlsRight input, #controlsRight select"
      );
      allInputs.forEach(el => {
        if (el.type === "checkbox") {
          settings[el.id] = el.checked;
        } else {
          settings[el.id] = el.value;
        }
      });
      const waveX = document.getElementById("waveTypeX");
      const waveY = document.getElementById("waveTypeY");
      const waveZ = document.getElementById("waveTypeZ");
      const waveW = document.getElementById("waveTypeW");
      const wireB = document.getElementById("wireframeBtn");
      if (waveX) settings.waveTypeXState = waveX.dataset.wave;
      if (waveY) settings.waveTypeYState = waveY.dataset.wave;
      if (waveZ) settings.waveTypeZState = waveZ.dataset.wave;
      if (waveW) settings.waveTypeWState = waveW.dataset.wave;
      if (wireB) settings.wireframeBtnState = wireB.dataset.wireframe;
      return settings;
    }

    /********************************************************
     * (D) APPLY JSON SETTINGS TO THE UI
     ********************************************************/
    function setSettings(settings) {
      const allInputs = document.querySelectorAll(
        "#controlsLeft input, #controlsLeft select, #controlsRight input, #controlsRight select"
      );
      allInputs.forEach(el => {
        if (settings.hasOwnProperty(el.id)) {
          if (el.type === "checkbox") {
            el.checked = settings[el.id];
          } else {
            el.value = settings[el.id];
          }
          // Trigger "input" so existing logic updates
          el.dispatchEvent(new Event("input"));
        }
      });
      const waveX = document.getElementById("waveTypeX");
      const waveY = document.getElementById("waveTypeY");
      const waveZ = document.getElementById("waveTypeZ");
      const waveW = document.getElementById("waveTypeW");
      const wireB = document.getElementById("wireframeBtn");

      if (waveX && settings.waveTypeXState) {
        updateWaveButtonUI(waveX, settings.waveTypeXState);
      }
      if (waveY && settings.waveTypeYState) {
        updateWaveButtonUI(waveY, settings.waveTypeYState);
      }
      if (waveZ && settings.waveTypeZState) {
        updateWaveButtonUI(waveZ, settings.waveTypeZState);
      }
      if (waveW && settings.waveTypeWState) {
        updateWaveButtonUI(waveW, settings.waveTypeWState);
      }
      if (wireB && settings.wireframeBtnState) {
        updateWireframeButtonUI(wireB, settings.wireframeBtnState);
      }
    }

    /********************************************************
     * (E) HOOK UP THE "SAVE" & "LOAD" BUTTONS
     ********************************************************/
    document.getElementById("saveSettings").addEventListener("click", () => {
      const settings = getSettings();
      const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(settings, null, 2));
      const fileName = getFrequencyFileName();
      const downloadAnchor = document.createElement("a");
      downloadAnchor.setAttribute("href", dataStr);
      downloadAnchor.setAttribute("download", fileName);
      document.body.appendChild(downloadAnchor);
      downloadAnchor.click();
      downloadAnchor.remove();
    });

    document.getElementById("loadSettings").addEventListener("click", () => {
      document.getElementById("loadSettingsFile").click();
    });

    document.getElementById("loadSettingsFile").addEventListener("change", event => {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const settings = JSON.parse(e.target.result);
          setSettings(settings);
        } catch (err) {
          alert("Error parsing JSON:\n" + err);
        }
      };
      reader.readAsText(file);
    });
  </script>

  <script>
    /********************************************************
     * INIT/RESET ("INITIALIZE") BUTTON
     ********************************************************/
    let defaultSettings = getSettings();
    document.getElementById("initializeSettings").addEventListener("click", () => {
      setSettings(defaultSettings);
    });


/********************************************************
 * 4D- & 3D-SPHERE DATA (POLAR MODE)
 ********************************************************/
let sphere4DVertices = [];
let sphere4DEdges = [];
let sphere3DVertices = [];
let sphere3DEdges = [];

// Create a 4D "3-sphere" wireframe at radius=1
// by sampling alpha1 in [0..2π], alpha2 in [0..π], alpha3 in [0..π].
function generate4DSphereGrid(stepDeg = 90) {
  sphere4DVertices = [];
  sphere4DEdges = [];

  const step = (Math.PI/180) * stepDeg;
  let alpha1Count = Math.floor((2*Math.PI)/step) + 1;
  let alpha2Count = Math.floor((Math.PI)/step) + 1;
  let alpha3Count = Math.floor((Math.PI)/step) + 1;

  // Helper to map (i,j,k) -> index in the array
  function idx(i,j,k) {
    return i*(alpha2Count*alpha3Count) + j*alpha3Count + k;
  }

  // Generate the vertices
  for (let i=0; i<alpha1Count; i++){
    let a1 = i*step;
    if (a1>2*Math.PI) a1 = 2*Math.PI; // clamp last step

    for (let j=0; j<alpha2Count; j++){
      let a2 = j*step;
      if (a2>Math.PI) a2 = Math.PI;

      for (let k=0; k<alpha3Count; k++){
        let a3 = k*step;
        if (a3>Math.PI) a3 = Math.PI;

        // 4D spherical => x,y,z,w
        // radius=1
        let x = Math.cos(a1);
        let y = Math.sin(a1) * Math.cos(a2);
        let z = Math.sin(a1) * Math.sin(a2) * Math.cos(a3);
        let w = Math.sin(a1) * Math.sin(a2) * Math.sin(a3);

        sphere4DVertices.push({x, y, z, w});
      }
    }
  }

  // Generate edges by connecting neighbors in each dimension
  for (let i=0; i<alpha1Count; i++){
    for (let j=0; j<alpha2Count; j++){
      for (let k=0; k<alpha3Count; k++){
        let base = idx(i,j,k);
        // connect i->i+1
        if (i+1<alpha1Count) sphere4DEdges.push([ base, idx(i+1,j,k) ]);
        // connect j->j+1
        if (j+1<alpha2Count) sphere4DEdges.push([ base, idx(i,j+1,k) ]);
        // connect k->k+1
        if (k+1<alpha3Count) sphere4DEdges.push([ base, idx(i,j,k+1) ]);
      }
    }
  }
}

// Create a 3D sphere wireframe at radius=1
// by sampling theta in [0..2π], phi in [0..π].
function generate3DSphereGrid(stepDeg = 90) {
  sphere3DVertices = [];
  sphere3DEdges = [];

  const step = (Math.PI/180)*stepDeg;
  let thetaCount = Math.floor((2*Math.PI)/step) + 1; // [0..2π]
  let phiCount   = Math.floor((Math.PI)/step) + 1;   // [0..π]

  function idx(i,j) {
    return i*phiCount + j;
  }

  for (let i=0; i<thetaCount; i++){
    let theta = i*step;
    if (theta>2*Math.PI) theta=2*Math.PI;

    for (let j=0; j<phiCount; j++){
      let phi = j*step;
      if (phi>Math.PI) phi=Math.PI;

      let x = Math.sin(phi)*Math.cos(theta);
      let y = Math.sin(phi)*Math.sin(theta);
      let z = Math.cos(phi);
      let w = 0;
      sphere3DVertices.push({x, y, z, w});
    }
  }

  for (let i=0; i<thetaCount; i++){
    for (let j=0; j<phiCount; j++){
      let base = idx(i,j);
      // connect i->i+1
      if (i+1<thetaCount) sphere3DEdges.push([base, idx(i+1,j)]);
      // connect j->j+1
      if (j+1<phiCount)   sphere3DEdges.push([base, idx(i,j+1)]);
    }
  }
}

// Call them once on startup with 90° steps
generate4DSphereGrid(90);
generate3DSphereGrid(90);

</script>
<!-- ===============================
     CHUNK #3: DRAWING POLAR WIREFRAME
     =============================== -->
<script>
function drawWireframePolar(ax, ay, az, aXY, aXZ, aXW, aYZ, aYW, aZW, camZ) {
  // 1) Draw 4D-sphere with dotted lines
  ctx.save();
  ctx.lineWidth = 1;
  ctx.setLineDash([4,4]);  // dashed lines
  ctx.strokeStyle = "rgba(251,246,228,0.5)";

  // Project each sphere4D vertex
  let proj4D = sphere4DVertices.map((v) => {
    // rotate in 4D
    let r = rotateXY(v, aXY);
    r = rotateXZ(r, aXZ);
    r = rotateXW(r, aXW);
    r = rotateYZ(r, aYZ);
    r = rotateYW(r, aYW);
    r = rotateZW(r, aZW);

    // 4D->3D perspective
    let d4 = 5;
    let factor4 = d4 / (d4 - r.w);
    let x3 = r.x * factor4;
    let y3 = r.y * factor4;
    let z3 = r.z * factor4;

    // then 3D rotation
    let rotated3 = rotateXYZ(x3, y3, z3, ay, ax, az);
    let xr = rotated3.x;
    let yr = rotated3.y;
    let zr = rotated3.z;

    // camera projection
    let denom = camZ - zr;
    if (Math.abs(denom) < 1e-5) denom = 1e-5;
    let scale = Math.min(canvas.width, canvas.height)*0.45;
    let px = canvas.width*0.5 + (xr/denom)*scale;
    let py = canvas.height*0.5 - (yr/denom)*scale;
    return {x: px, y: py};
  });

  // draw edges
  for (let [start, end] of sphere4DEdges) {
    let A = proj4D[start], B = proj4D[end];
    ctx.beginPath();
    ctx.moveTo(A.x, A.y);
    ctx.lineTo(B.x, B.y);
    ctx.stroke();
  }
  ctx.restore();

  // 2) Draw 3D-sphere with solid lines
  ctx.save();
  ctx.lineWidth = 2;
  ctx.setLineDash([]);
  ctx.strokeStyle = "rgba(251,246,228,0.5)";

  let proj3D = sphere3DVertices.map((v) => {
    // rotate in 4D (though w=0, so only angles matter)
    let r = rotateXY(v, aXY);
    r = rotateXZ(r, aXZ);
    r = rotateXW(r, aXW);
    r = rotateYZ(r, aYZ);
    r = rotateYW(r, aYW);
    r = rotateZW(r, aZW);

    // 4D->3D
    let d4 = 5;
    let factor4 = d4 / (d4 - r.w);
    let x3 = r.x * factor4;
    let y3 = r.y * factor4;
    let z3 = r.z * factor4;

    // 3D rotation
    let rotated3 = rotateXYZ(x3, y3, z3, ay, ax, az);
    let xr = rotated3.x;
    let yr = rotated3.y;
    let zr = rotated3.z;

    // camera
    let denom = camZ - zr;
    if (Math.abs(denom) < 1e-5) denom = 1e-5;
    let scale = Math.min(canvas.width, canvas.height)*0.45;
    let px = canvas.width*0.5 + (xr/denom)*scale;
    let py = canvas.height*0.5 - (yr/denom)*scale;
    return { x:px, y:py };
  });

  for (let [start, end] of sphere3DEdges) {
    let A = proj3D[start], B = proj3D[end];
    ctx.beginPath();
    ctx.moveTo(A.x, A.y);
    ctx.lineTo(B.x, B.y);
    ctx.stroke();
  }

  ctx.restore();
}
</script>


  </script>
</body>
</html>
